<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Shooter JS</title>
    <!-- Load Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #1a1a2e; /* Dark space background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        #game-container {
            border: 4px solid #4a4e69;
            box-shadow: 0 0 30px rgba(74, 78, 105, 0.5);
            border-radius: 12px;
            overflow: hidden;
            background-color: #0d0d18;
            max-width: 600px;
            width: 100%;
        }
        #gameCanvas {
            display: block;
            background-color: #000;
        }
    </style>
</head>
<body class="p-4">

    <div id="game-container" class="flex flex-col items-center p-4">
        
        <header class="text-center mb-4">
            <h1 class="text-3xl font-extrabold text-indigo-400">Cosmic Blast!</h1>
            <p class="text-gray-300 text-sm">Use &larr; &rarr; to move and SPACE to shoot.</p>
        </header>

        <canvas id="gameCanvas" width="500" height="400"></canvas>

        <div id="status-area" class="mt-4 w-full flex justify-between items-center text-gray-200 font-bold">
            <div id="score" class="text-lg text-yellow-300">Score: 0</div>
            <button id="startButton" class="px-4 py-2 bg-green-600 hover:bg-green-700 text-white font-bold rounded-lg shadow-md transition duration-200">
                Start Game
            </button>
        </div>

    </div>

    <!-- CRITICAL FIX: Added type="module" to resolve the SyntaxError -->
    <script type="module">
        // --- Setup ---
import pygame
import random
import sys
import os
import json


# --- 1. CONFIGURATION & FILE PATHS ---
SCREEN_WIDTH = 1350
SCREEN_HEIGHT = 950
FPS = 45


# --- CRITICAL FIX: Missing definition added here ---
SCHEDULED_SPAWN_COUNT = 10
# ----------------------------------------------------


# File paths (Unchanged)
LEADERBOARD_FILE = "leaderboard.json"
HIT_STREAK_FILE = "hit_streak_leaderboard.json"
PERFECT_PILOT_FILE = "perfect_pilot_leaderboard.json"
CONFIG_FILE = "config.json"


# Developer settings
DEV_CODE = "1223"


# Define colors (Unchanged)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
YELLOW = (255, 255, 0)
GRAY = (100, 100, 100)
CYAN_BLUE = (0, 200, 200)
ORANGE = (255, 165, 0)
BLUE = (50, 50, 255)
DARK_GRAY = (20, 20, 20)
LIGHT_GRAY = (40, 40, 40)


# Initialize Pygame
pygame.init()


# --- INITIAL SCREEN SETUP ---
# 'screen' is the actual display window/monitor surface
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.RESIZABLE)
pygame.display.set_caption("Space Shooter Prototype")
clock = pygame.time.Clock()
is_fullscreen = False


# --- SCALING AND CENTERING VARIABLES ---
GAME_SURFACE = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT)) # The fixed 1350x950 surface we draw everything to
# Initial values for windowed mode
current_display_width = SCREEN_WIDTH
current_display_height = SCREEN_HEIGHT
scaled_game_width = SCREEN_WIDTH
scaled_game_height = SCREEN_HEIGHT
x_offset = 0
y_offset = 0
# ---------------------------


# Initialize Fonts (Unchanged)
font_default = pygame.font.Font(None, 36)
font_title = pygame.font.Font(None, 72)
font_menu = pygame.font.Font(None, 50)
font_large = pygame.font.Font(None, 45)


# --- 2. GLOBAL INITIAL SETUP (UPDATED FOR LUCKY BLOCK COUNTER) ---
all_sprites = pygame.sprite.Group()
enemies = pygame.sprite.Group()
bullets = pygame.sprite.Group()
lucky_blocks = pygame.sprite.Group()
scheduled_spawns = [] # Ensure this is initialized


# Game state variables (Unchanged)
score = 0
lives = 3
player = None
paused = False


lives_lost_since_level = 0
num_enemies_target = 3
score_level = 0
perfect_round_streak = 0


# Streak variables 
hit_streak = 0
score_multiplier = 1.0
max_hit_streak_achieved = 0


# Power-up variables (Updated for variable durations)
FPS_RATE = 45
SHORT_DURATION = 5 * FPS_RATE      # 5 seconds
LONG_DURATION = 10 * FPS_RATE     # 10 seconds
LUCKY_BLOCK_LIFESPAN = 60 * FPS_RATE # 60 seconds


fire_rate_boost_timer = 0
powerup_multi_shot = 1
invincible_powerup_timer = 0
streak_saver_active = False
enemies_killed_total = 0
# --- NEW LUCKY BLOCK COUNTER ---
kills_to_next_lucky_block = 25
# -------------------------------


# Config variables (Unchanged)
games_played = 0
sight_mode = False
dev_code_buffer = ""


# Leaderboard data (Unchanged)
username = "Player1"
leaderboard_data = []
hit_streak_data = []
perfect_pilot_data = []


# --- 3. PERSISTENCE & LEADERBOARD FUNCTIONS (SIMULATED STORAGE FOR PYODIDE) ---
# NOTE: File I/O is restricted in the web environment. This uses a global dictionary
# to simulate persistence, ensuring the game logic runs without crashing.

__SIMULATED_STORAGE = {
    LEADERBOARD_FILE: [],
    HIT_STREAK_FILE: [],
    PERFECT_PILOT_FILE: [],
    CONFIG_FILE: {'games_played': 0, 'sight_mode': False}
}

def _load_data(file_name):
    """Internal helper to load data from simulated storage."""
    # This structure works for both lists (leaderboards) and dicts (config)
    return __SIMULATED_STORAGE.get(file_name, []) if file_name.endswith('.json') else __SIMULATED_STORAGE.get(file_name, {})

def _save_data(file_name, data):
    """Internal helper to save data to simulated storage."""
    __SIMULATED_STORAGE[file_name] = data

def delete_file_if_exists(file_name):
   """Safely 'deletes' data from simulated storage."""
   if file_name in __SIMULATED_STORAGE:
       if file_name == CONFIG_FILE:
           __SIMULATED_STORAGE[file_name] = {'games_played': 0, 'sight_mode': False}
       else:
           __SIMULATED_STORAGE[file_name] = []
   print(f"Simulated deletion of {file_name} completed.")


def load_config():
   """Loads configuration data."""
   global games_played, sight_mode
   config = _load_data(CONFIG_FILE)
   games_played = config.get('games_played', 0)
   sight_mode = config.get('sight_mode', False)


def save_config():
   """Saves configuration data."""
   config = {'games_played': games_played, 'sight_mode': sight_mode}
   _save_data(CONFIG_FILE, config)


def load_leaderboard(file_name):
   """Loads leaderboard from simulated storage."""
   return _load_data(file_name)


def save_leaderboard(file_name, data):
   """Saves the current leaderboard data."""
   _save_data(file_name, data)


def initialize_leaderboards_and_config():
    """Load all leaderboards and configuration at startup."""
    global leaderboard_data, hit_streak_data, perfect_pilot_data
    
    load_config()
    
    # Load from the global dictionary
    leaderboard_data = load_leaderboard(LEADERBOARD_FILE)
    hit_streak_data = load_leaderboard(HIT_STREAK_FILE)
    perfect_pilot_data = load_leaderboard(PERFECT_PILOT_FILE)
    
    if leaderboard_data:
        # Return the highest score found
        return max(entry.get('score', 0) for entry in leaderboard_data)
    return 0


def update_leaderboards(name, final_score, max_h_streak, perfect_streak):
    """Adds final game stats to all relevant leaderboards."""
    global leaderboard_data, hit_streak_data, perfect_pilot_data
    
    # High Score Board
    leaderboard_data.append({'name': name, 'score': final_score})
    leaderboard_data.sort(key=lambda x: x['score'], reverse=True)
    leaderboard_data = leaderboard_data[:10]
    _save_data(LEADERBOARD_FILE, leaderboard_data)

    # Hit Streak Board
    hit_streak_data.append({'name': name, 'streak': max_h_streak})
    hit_streak_data.sort(key=lambda x: x['streak'], reverse=True)
    hit_streak_data = hit_streak_data[:10]
    _save_data(HIT_STREAK_FILE, hit_streak_data)

    # Perfect Pilot Board
    perfect_pilot_data.append({'name': name, 'streak': perfect_streak})
    perfect_pilot_data.sort(key=lambda x: x['streak'], reverse=True)
    perfect_pilot_data = perfect_pilot_data[:10]
    _save_data(PERFECT_PILOT_FILE, perfect_pilot_data)

def reset_all_history():
    """Resets all game history by clearing simulated storage and reloading."""
    global leaderboard_data, hit_streak_data, perfect_pilot_data, games_played, sight_mode
    
    # 1. Permanently delete all data from simulated storage
    delete_file_if_exists(LEADERBOARD_FILE)
    delete_file_if_exists(HIT_STREAK_FILE)
    delete_file_if_exists(PERFECT_PILOT_FILE)
    delete_file_if_exists(CONFIG_FILE) # This resets config to defaults
    
    # 2. Clear in-memory data (will be reloaded by initialize)
    leaderboard_data = []
    hit_streak_data = []
    perfect_pilot_data = []
    games_played = 0
    sight_mode = False
    
    print("ALL GAME HISTORY PERMANENTLY DELETED.")
# ---------------------------------------------------------------------------------


def draw_text(surf, text, size, x, y, color=WHITE, align="center"):
   """Helper function to display text on the designated surface."""
   if size >= 60:
       f = font_title
   elif size >= 45:
       f = font_large
   elif size >= 36:
       f = font_default
   else:
       f = pygame.font.Font(None, size)
      
   text_surface = f.render(text, True, color)
   text_rect = text_surface.get_rect()
  
   if align == "center":
       text_rect.midtop = (x, y)
   elif align == "left":
       text_rect.topleft = (x, y)
   elif align == "right":
       text_rect.topright = (x, y)
      
   surf.blit(text_surface, text_rect)


# --- 4. GAME OBJECT CLASSES (Unchanged) ---
class Player(pygame.sprite.Sprite):
   def __init__(self):
       super().__init__()
       self.original_image = pygame.Surface([30, 30], pygame.SRCALPHA)
       pygame.draw.polygon(self.original_image, CYAN_BLUE, [(15, 0), (0, 30), (30, 30)])
       pygame.draw.polygon(self.original_image, WHITE, [(15, 0), (0, 30), (30, 30)], 2)
       pygame.draw.rect(self.original_image, YELLOW, [5, 25, 5, 5])
       pygame.draw.rect(self.original_image, YELLOW, [20, 25, 5, 5])
       self.image = self.original_image.copy()
       self.rect = self.image.get_rect()
       self.rect.centerx = SCREEN_WIDTH // 2
       self.rect.bottom = SCREEN_HEIGHT - 10
       self.speed = 8
       self.last_shot_time = pygame.time.get_ticks()
       self.base_shot_delay = 175
       self.hit_delay = 2000 # 2 seconds of standard invincibility
       self.last_hit_time = 0
       self.invincible = False
       self.flash_timer = 0


   def update(self):
       global fire_rate_boost_timer, powerup_multi_shot, invincible_powerup_timer
       keys = pygame.key.get_pressed()
       if keys[pygame.K_LEFT] or keys[pygame.K_a]:
           self.rect.x -= self.speed
       if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
           self.rect.x += self.speed
       self.rect.left = max(0, self.rect.left)
       self.rect.right = min(SCREEN_WIDTH, self.rect.right)


       now = pygame.time.get_ticks()
       if fire_rate_boost_timer > 0:
           self.shot_delay = self.base_shot_delay * 0.5
       else:
           self.shot_delay = self.base_shot_delay


       is_powerup_invincible = invincible_powerup_timer > 0
      
       if is_powerup_invincible:
           self.invincible = True # Power-up overrides standard invincibility
           if self.flash_timer % 5 < 3:
               self.image = pygame.Surface([30, 30], pygame.SRCALPHA)
               pygame.draw.polygon(self.image, YELLOW, [(15, 0), (0, 30), (30, 30)])
               pygame.draw.rect(self.image, ORANGE, [5, 25, 5, 5])
               pygame.draw.rect(self.image, ORANGE, [20, 25, 5, 5])
           else:
               self.image = self.original_image.copy()
           self.flash_timer += 1
       elif self.invincible:
           # Standard invincibility after taking damage
           if now - self.last_hit_time > self.hit_delay:
               self.invincible = False
               self.image = self.original_image.copy()
           else:
               self.flash_timer += 1
               if self.flash_timer % 10 < 5:
                   self.image = pygame.Surface([30, 30], pygame.SRCALPHA)
                   pygame.draw.polygon(self.image, GRAY, [(15, 0), (0, 30), (30, 30)])
                   pygame.draw.polygon(self.image, WHITE, [(15, 0), (0, 30), (30, 30)], 2)
               else:
                   self.image = self.original_image.copy()
       else:
           self.image = self.original_image.copy()


   def shoot(self):
       global hit_streak, score_multiplier, powerup_multi_shot, streak_saver_active
       now = pygame.time.get_ticks()
       if now - self.last_shot_time > self.shot_delay:
           self.last_shot_time = now
           bullets_to_spawn = []
           current_multi_shot = int(powerup_multi_shot)
           if current_multi_shot == 1:
               bullets_to_spawn.append(self.rect.centerx)
           elif current_multi_shot == 2:
               bullets_to_spawn.append(self.rect.centerx - 8)
               bullets_to_spawn.append(self.rect.centerx + 8)
           elif current_multi_shot == 3:
               bullets_to_spawn.append(self.rect.centerx - 16)
               bullets_to_spawn.append(self.rect.centerx)
               bullets_to_spawn.append(self.rect.centerx + 16)


           has_target_in_path = False
           for x_pos in bullets_to_spawn:
               bullet = Bullet(x_pos, self.rect.top)
               if check_bullet_hit_path(bullet.rect.centerx, bullet.rect.width):
                   has_target_in_path = True
               flash = MuzzleFlash(x_pos, self.rect.top)
               all_sprites.add(bullet, flash)
               bullets.add(bullet)


           if not has_target_in_path:
               if streak_saver_active:
                   streak_saver_active = False
               elif hit_streak > 0:
                   hit_streak = 0
                   score_multiplier = 1.0
          
   # Removed lose_life() method. Life loss logic is now handled clearly in the main loop.
   # The Player class's update method now only manages the visual invincibility state.


class Enemy(pygame.sprite.Sprite):
   def __init__(self):
       super().__init__()
       self.image = pygame.Surface([30, 30], pygame.SRCALPHA)
       diamond_points = [(15, 0), (30, 15), (15, 30), (0, 15)]
       pygame.draw.polygon(self.image, RED, diamond_points)
       pygame.draw.circle(self.image, GRAY, (15, 15), 5)
       self.rect = self.image.get_rect()
       self.rect.x = random.randrange(SCREEN_WIDTH - self.rect.width)
       self.rect.y = random.randrange(-100, -40)
       self.speedy = random.randrange(1, 4)


   def update(self):
       self.rect.y += self.speedy


class Bullet(pygame.sprite.Sprite):
   def __init__(self, x, y):
       super().__init__()
       self.image = pygame.Surface([4, 10])
       self.image.fill(WHITE)
       self.rect = self.image.get_rect()
       self.rect.centerx = x
       self.rect.bottom = y
       self.speedy = -10


   def update(self):
       self.rect.y += self.speedy
       if self.rect.bottom < 0:
           self.kill()


class MuzzleFlash(pygame.sprite.Sprite):
   def __init__(self, x, y):
       super().__init__()
       self.lifespan = 3
       self.frame = 0
       self.image = pygame.Surface([10, 10], pygame.SRCALPHA)
       pygame.draw.circle(self.image, ORANGE, (5, 5), 5)
       self.rect = self.image.get_rect()
       self.rect.centerx = x
       self.rect.top = y - 5
      
   def update(self):
       self.frame += 1
       if self.frame > self.lifespan:
           self.kill()


class Explosion(pygame.sprite.Sprite):
   def __init__(self, center):
       super().__init__()
       self.lifespan = 8
       self.frame = 0
       self.image = pygame.Surface([50, 50], pygame.SRCALPHA)
       self.rect = self.image.get_rect(center=center)
       self.center = center
      
   def update(self):
       self.frame += 1
       size = 50 - (self.frame * 5)
       if size < 1:
           self.kill()
           return
      
       new_image = pygame.Surface([50, 50], pygame.SRCALPHA)
       pygame.draw.circle(new_image, RED, (25, 25), size // 2)
       pygame.draw.circle(new_image, ORANGE, (25, 25), size // 3)
      
       self.image = new_image
       self.rect = self.image.get_rect(center=self.center)
      
class LuckyBlock(pygame.sprite.Sprite):
   def __init__(self):
       super().__init__()
       self.image = pygame.Surface([30, 30], pygame.SRCALPHA)
       self.image.fill(YELLOW)
       draw_text(self.image, "?", 36, 15, 0, BLACK)
      
       self.rect = self.image.get_rect()
       self.rect.x = random.randrange(SCREEN_WIDTH - self.rect.width)
       self.rect.y = random.randrange(-150, -50)
       self.speedy = random.randrange(2, 5)
      
       # New: Track spawn time for lifespan control
       self.spawn_time = pygame.time.get_ticks()


   def update(self):
       self.rect.y += self.speedy
      
       # New: Check for max lifespan (60 seconds)
       # We use 1000/FPS as approximation for milliseconds per frame
       if (pygame.time.get_ticks() - self.spawn_time) > LUCKY_BLOCK_LIFESPAN * (1000 / 45): 
           self.kill()


       if self.rect.top > SCREEN_HEIGHT:
           self.kill()


# --- 5. GAME LOGIC FUNCTIONS ---


def calculate_score_for_next_level(current_level_index):
   """
   Calculates the cumulative score required to reach the next level
   (current_level_index + 1). Progression starts at 500 and increases
   by 250 points per subsequent level requirement.
   """
   N = current_level_index + 1 # Target level index (1-based)
  
   if N == 1:
       return 500 # Score required to complete Level 1
      
   total_score = 500 # Start with score for Level 1
  
   # Calculate and add the required score for levels 2 through N
   for i in range(1, N): # i will be 1, 2, 3, ... N-1
       # Increase for level i+1: 500 + 250 * i
       total_score += (500 + 250 * i)
      
   return total_score


def toggle_fullscreen():
   """Toggles between windowed and native fullscreen, updating offsets and scaling."""
   global is_fullscreen, screen, current_display_width, current_display_height, x_offset, y_offset, scaled_game_width, scaled_game_height
  
   # Toggle the state first
   is_fullscreen = not is_fullscreen


   if is_fullscreen:
       # Switch to fullscreen mode
       info = pygame.display.Info()
       current_display_width = info.current_w
       current_display_height = info.current_h
       flags = pygame.FULLSCREEN
      
   else:
       # Switch back to windowed mode (using the configured SCREEN_WIDTH/HEIGHT)
       current_display_width = SCREEN_WIDTH
       current_display_height = SCREEN_HEIGHT
       flags = pygame.RESIZABLE
      
   # Recreate the main display surface with the new size and flags
   screen = pygame.display.set_mode((current_display_width, current_display_height), flags)
      
   # --- SCALING CALCULATION (Aspect Ratio Preserved) ---
   scale_w = current_display_width / SCREEN_WIDTH
   scale_h = current_display_height / SCREEN_HEIGHT
   scale_factor = min(scale_w, scale_h)
  
   # Apply scale factor to game dimensions
   scaled_game_width = int(SCREEN_WIDTH * scale_factor)
   scaled_game_height = int(SCREEN_HEIGHT * scale_factor)
  
   # Calculate offset to center the *scaled* surface on the actual screen
   x_offset = (current_display_width - scaled_game_width) // 2
   y_offset = (current_display_height - scaled_game_height) // 2
  
   print(f"--- MODE CHANGE --- Fullscreen: {is_fullscreen}, Display: {current_display_width}x{current_display_height}, Game Area: {scaled_game_width}x{scaled_game_height}, Offset: {x_offset}x{y_offset}")


  
def generate_scheduled_spawns(count):
   """Generates the next 'count' enemy spawn x-positions for predictive streak checking."""
   global scheduled_spawns
   scheduled_spawns = []
   for _ in range(count):
       x_pos = random.randrange(0, SCREEN_WIDTH - 30)
       scheduled_spawns.append(x_pos)


def check_bullet_hit_path(bullet_x_center, bullet_width):
   """Checks if a bullet is vertically aligned with any active enemy or any scheduled spawn."""
  
   for enemy in enemies:
       if enemy.rect.left <= bullet_x_center <= enemy.rect.right:
           return True
      
   for block in lucky_blocks:
        if block.rect.left <= bullet_x_center <= block.rect.right:
           return True
          
   enemy_width = 30
   bullet_left = bullet_x_center - (bullet_width / 2)
   bullet_right = bullet_x_center + (bullet_width / 2)
  
   for x_pos in scheduled_spawns:
       spawn_left = x_pos
       spawn_right = x_pos + enemy_width
      
       if max(bullet_left, spawn_left) < min(bullet_right, spawn_right):
           return True
          
   return False


def reset_game():
   """Initializes all sprites and game variables for a new round."""
   global all_sprites, enemies, bullets, lucky_blocks, player, score, lives, paused, num_enemies_target, score_level, lives_lost_since_level, hit_streak, score_multiplier, max_hit_streak_achieved, perfect_round_streak, fire_rate_boost_timer, powerup_multi_shot, invincible_powerup_timer, streak_saver_active, enemies_killed_total, games_played, kills_to_next_lucky_block
  
   all_sprites.empty()
   enemies.empty()
   bullets.empty()
   lucky_blocks.empty()


   score = 0
   lives = 3
   paused = False


   num_enemies_target = 3
   score_level = 0
   lives_lost_since_level = 0
  
   hit_streak = 0
   score_multiplier = 1.0
   max_hit_streak_achieved = 0
   perfect_round_streak = 0
  
   fire_rate_boost_timer = 0
   powerup_multi_shot = 1
   invincible_powerup_timer = 0
   streak_saver_active = False
  
   enemies_killed_total = 0
   # Reset the counter to start the new game cycle
   kills_to_next_lucky_block = 25
  
   games_played += 1
   save_config()


   player = Player()
   all_sprites.add(player)
  
   # This line now works because SCHEDULED_SPAWN_COUNT is defined
   generate_scheduled_spawns(SCHEDULED_SPAWN_COUNT)


   for _ in range(num_enemies_target):
       enemy = Enemy()
       all_sprites.add(enemy)
       enemies.add(enemy)


def check_and_spawn_enemies():
   """Checks the score for level-ups, handles bonuses, and spawns enemies and lucky blocks."""
   global score, num_enemies_target, score_level, lives, lives_lost_since_level, perfect_round_streak, scheduled_spawns, kills_to_next_lucky_block


   # --- UPDATED LEVEL LOGIC ---
   next_level_threshold = calculate_score_for_next_level(score_level)
  
   # Check if the player has passed the threshold for the next level
   if score >= next_level_threshold:
      
       # Increase the level counter
       score_level += 1
      
       if lives_lost_since_level == 0:
           perfect_round_streak += 1
           lives_gained = perfect_round_streak
           lives += lives_gained
           score += 100 # Bonus score for perfect round
       else:
           perfect_round_streak = 0
      
       lives_lost_since_level = 0
      
       # Increase target enemy count based on the new level
       num_enemies_target += 1 # Every level adds one enemy to the target count
      
   # --- END UPDATED LEVEL LOGIC ---
      
   current_enemies = len(enemies)
   enemies_to_spawn = num_enemies_target - current_enemies
  
   for _ in range(enemies_to_spawn):
       if scheduled_spawns:
           x_pos = scheduled_spawns.pop(0)
       else:
           x_pos = random.randrange(0, SCREEN_WIDTH - 30)


       new_enemy = Enemy()
       new_enemy.rect.x = x_pos
      
       all_sprites.add(new_enemy)
       enemies.add(new_enemy)
      
       if len(scheduled_spawns) < SCHEDULED_SPAWN_COUNT:
            generate_scheduled_spawns(SCHEDULED_SPAWN_COUNT - len(scheduled_spawns))


   # --- UPDATED LUCKY BLOCK SPAWN LOGIC (Fixed for 25-kill interval) ---
   # Check if the kill counter is zero AND there is no block currently on screen.
   if kills_to_next_lucky_block <= 0 and len(lucky_blocks) == 0:
       new_block = LuckyBlock()
       all_sprites.add(new_block)
       lucky_blocks.add(new_block)
       kills_to_next_lucky_block = 25 # Reset the counter for the next cycle
   # ---------------------------------------------------------


def apply_powerup():
   """Randomly selects and applies a power-up with new names and durations."""
   global lives, hit_streak, score_multiplier, fire_rate_boost_timer, powerup_multi_shot, invincible_powerup_timer, streak_saver_active
  
   # Updated list with cool names and short/long duration options
   powerups = [
       ("Pulse Accelerator", "FIRE_SHORT"),
       ("Hyperburner Boost", "FIRE_LONG"),
       ("Dual Canon", "MULTI_2"),
       ("Tri-Splinter", "MULTI_3"),
       ("Phase Shield", "INVINCIBLE_SHORT"),
       ("Quantum Cloak", "INVINCIBLE_LONG"),
       ("Life Giver", "LIFE"),
       ("Streak Multiplier", "STREAK_X5"),
       ("Streak Saver", "SAVER")
   ]
  
   chosen_powerup_name, chosen_powerup_type = random.choice(powerups)
  
   # Reset existing timer/state-based powerups (except multi-shot)
   fire_rate_boost_timer = 0
   invincible_powerup_timer = 0
  
   if chosen_powerup_type == "FIRE_SHORT":
       fire_rate_boost_timer = SHORT_DURATION
   elif chosen_powerup_type == "FIRE_LONG":
       fire_rate_boost_timer = LONG_DURATION
   elif chosen_powerup_type == "MULTI_2":
       powerup_multi_shot = 2
   elif chosen_powerup_type == "MULTI_3":
       powerup_multi_shot = 3
   elif chosen_powerup_type == "INVINCIBLE_SHORT":
       invincible_powerup_timer = SHORT_DURATION
   elif chosen_powerup_type == "INVINCIBLE_LONG":
       invincible_powerup_timer = LONG_DURATION
   elif chosen_powerup_type == "LIFE":
       lives += 1
   elif chosen_powerup_type == "STREAK_X5":
       hit_streak *= 5
       score_multiplier = 1.0 + (hit_streak * 0.5)
   elif chosen_powerup_type == "SAVER":
       streak_saver_active = True
      
   print(f"Power-up activated: {chosen_powerup_name}")
  
def show_game_over_screen(final_score):
   """Displays the game over screen with option to return to menu or restart."""
  
   GAME_SURFACE.fill(BLACK)
   draw_text(GAME_SURFACE, "GAME OVER", 72, SCREEN_WIDTH // 2, SCREEN_HEIGHT // 4, RED)
   draw_text(GAME_SURFACE, f"FINAL SCORE: {final_score}", 50, SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2, WHITE)
   draw_text(GAME_SURFACE, "Press M to return to Menu", 36, SCREEN_WIDTH // 2, SCREEN_HEIGHT * 3 // 4, GREEN)
   draw_text(GAME_SURFACE, "Press P to Play Again (New Name)", 36, SCREEN_WIDTH // 2, SCREEN_HEIGHT * 3 // 4 + 40, YELLOW)


   waiting = True
   while waiting:
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               return "QUIT"
           if event.type == pygame.KEYDOWN:
               if event.key == pygame.K_m:
                   return "MENU"
               if event.key == pygame.K_p:
                   return "PLAY"
               if event.key == pygame.K_f or event.key == pygame.K_F11:
                   toggle_fullscreen()


       # --- CRITICAL FIX 4: ADDED DRAWING LOGIC TO GAME OVER LOOP ---
       screen.fill(BLACK)
       scaled_surface = pygame.transform.scale(GAME_SURFACE, (scaled_game_width, scaled_game_height))
       screen.blit(scaled_surface, (x_offset, y_offset))
       pygame.display.flip()
       # -----------------------------------------------------------
       clock.tick(FPS)
   return "MENU"


def show_pause_screen(surf):
   """Display the pause overlay."""
   pause_text = font_title.render("PAUSED", True, YELLOW)
   rect = pause_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2))
   surf.blit(pause_text, rect)
  
def show_leaderboard_screen():
   """
   Displays leaderboards, drawing to GAME_SURFACE for centering, and handles code input.
   """
   global leaderboard_data, hit_streak_data, perfect_pilot_data, dev_code_buffer


   waiting = True
   current_board = "SCORE"
  
   # --- TAB LAYOUT RECALCULATION for 1350 Width ---
   tab_height = 50
   tab_width = 280 # Wider tabs
   tab_spacing = 30
   tab_y = 120
  
   total_tab_group_width = (3 * tab_width) + (2 * tab_spacing)
   start_x = (SCREEN_WIDTH // 2) - (total_tab_group_width // 2)


   perfect_tab_rect = pygame.Rect(start_x, tab_y, tab_width, tab_height) # Left tab
   hit_tab_rect = pygame.Rect(start_x + tab_width + tab_spacing, tab_y, tab_width, tab_height) # Center tab
   score_tab_rect = pygame.Rect(start_x + (tab_width + tab_spacing) * 2, tab_y, tab_width, tab_height) # Right tab
   # ---------------------------------------------


   while waiting:
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               return "QUIT"
              
           if event.type == pygame.MOUSEBUTTONDOWN:
               # --- Mouse Translation Logic: CRITICAL FOR FULLSCREEN CENTERING ---
               if scaled_game_width > 0 and scaled_game_height > 0:
                   # Calculate position relative to the scaled surface
                   relative_x = event.pos[0] - x_offset
                   relative_y = event.pos[1] - y_offset
                  
                   # Convert to 1350x950 coordinates
                   scale_factor_x = SCREEN_WIDTH / scaled_game_width
                   scale_factor_y = SCREEN_HEIGHT / scaled_game_height
                  
                   translated_x = int(relative_x * scale_factor_x)
                   translated_y = int(relative_y * scale_factor_y)
                   translated_pos = (translated_x, translated_y)
               else:
                   # Fallback for windowed mode
                   translated_pos = event.pos
              
               if score_tab_rect.collidepoint(translated_pos):
                   current_board = "SCORE"
               elif hit_tab_rect.collidepoint(translated_pos):
                   current_board = "HIT_STREAK"
               elif perfect_tab_rect.collidepoint(translated_pos):
                   current_board = "PERFECT_PILOT"
                  
           if event.type == pygame.KEYDOWN:
               # Menu navigation
               if event.key == pygame.K_m or event.key == pygame.K_ESCAPE:
                   dev_code_buffer = ""
                   return "MENU"
               if event.key == pygame.K_s:
                   current_board = "SCORE"
               if event.key == pygame.K_h:
                   current_board = "HIT_STREAK"
               if event.key == pygame.K_p:
                   current_board = "PERFECT_PILOT"
               if event.key == pygame.K_f or event.key == pygame.K_F11:
                   toggle_fullscreen()
                  
               # Developer Code Input Logic
               if event.key == pygame.K_BACKSPACE:
                   dev_code_buffer = dev_code_buffer[:-1]
               elif event.key == pygame.K_RETURN:
                   if dev_code_buffer == DEV_CODE:
                       dev_code_buffer = ""
                       return "DEV_MENU"
                   dev_code_buffer = ""
               elif event.unicode.isdigit():
                   if len(dev_code_buffer) < len(DEV_CODE):
                       dev_code_buffer += event.unicode


       # --- DRAW / RENDER to GAME_SURFACE ---
       GAME_SURFACE.fill(BLACK)
      
       # 1. Main Title
       draw_text(GAME_SURFACE, "HALL OF FAME", 72, SCREEN_WIDTH // 2, 50, CYAN_BLUE)
      
       # 2. Tab Navigation Drawing
       tabs = [
           ("PERFECT PILOT", perfect_tab_rect, "PERFECT_PILOT", pygame.K_p),
           ("HIT STREAK", hit_tab_rect, "HIT_STREAK", pygame.K_h),
           ("SCORE", score_tab_rect, "SCORE", pygame.K_s),
       ]
      
       for name, rect, board_key, key_code in tabs:
           is_active = current_board == board_key
           color = CYAN_BLUE if is_active else DARK_GRAY
           text_color = YELLOW if is_active else WHITE
          
           pygame.draw.rect(GAME_SURFACE, color, rect, border_radius=5)
           if is_active:
               pygame.draw.rect(GAME_SURFACE, YELLOW, rect, 2, border_radius=5)


           text_display = f"[{pygame.key.name(key_code).upper()}] {name}"
           draw_text(GAME_SURFACE, text_display, 30, rect.centerx, rect.y + 15, text_color, align="center")
          
       # 3. Leaderboard Panel Setup - Widened for 1350px
       panel_width = SCREEN_WIDTH * 0.8
       panel_x = (SCREEN_WIDTH - panel_width) // 2
       panel_rect = pygame.Rect(panel_x, 200, panel_width, SCREEN_HEIGHT - 300)
      
       pygame.draw.rect(GAME_SURFACE, DARK_GRAY, panel_rect, border_radius=10)
       pygame.draw.rect(GAME_SURFACE, CYAN_BLUE, panel_rect, 3, border_radius=10)


       # Select data
       if current_board == "SCORE":
           data = leaderboard_data
           key = 'score'
           col_header = 'SCORE'
       elif current_board == "HIT_STREAK":
           data = hit_streak_data
           key = 'streak'
           col_header = 'MAX STREAK'
       else:
           data = perfect_pilot_data
           key = 'streak'
           col_header = 'PERFECT STREAK'
          
       # 4. Column Headers - Evenly spread across the panel width
       col_y = panel_rect.top + 20
       col_margin = panel_rect.width / 8


       rank_x = panel_rect.left + col_margin
       name_x = panel_rect.centerx
       value_x = panel_rect.right - col_margin
      
       draw_text(GAME_SURFACE, "RANK", 40, rank_x, col_y, YELLOW, align="center")
       draw_text(GAME_SURFACE, "PILOT NAME", 40, name_x, col_y, YELLOW, align="center")
       draw_text(GAME_SURFACE, col_header, 40, value_x, col_y, YELLOW, align="center")
      
       pygame.draw.line(GAME_SURFACE, GRAY, (panel_rect.left + 20, col_y + 35), (panel_rect.right - 20, col_y + 35), 1)


       # 5. Draw Leaderboard Rows
       row_start_y = col_y + 50
       row_height = 45
      
       for i, entry in enumerate(data[:10]):
           rank = i + 1
           name = entry.get('name', 'N/A')
           value = entry.get(key, 0)
          
           row_color = LIGHT_GRAY if i % 2 == 1 else DARK_GRAY
           row_rect = pygame.Rect(panel_rect.left, row_start_y + i * row_height, panel_rect.width, row_height)
           pygame.draw.rect(GAME_SURFACE, row_color, row_rect)
          
           text_color = WHITE
           if rank == 1:
               text_color = YELLOW
           elif rank == 2:
               text_color = CYAN_BLUE
           elif rank == 3:
               text_color = ORANGE


           draw_text(GAME_SURFACE, f"{rank}.", 36, rank_x, row_rect.y + 10, text_color, align="center")
           draw_text(GAME_SURFACE, name, 36, name_x, row_rect.y + 10, text_color, align="center")
           draw_text(GAME_SURFACE, str(value), 36, value_x, row_rect.y + 10, text_color, align="center")


       # 6. Footer and Dev Code Input
       draw_text(GAME_SURFACE, "Press M or ESC to return to Menu", 30, SCREEN_WIDTH // 2, SCREEN_HEIGHT - 30, GRAY)
       if dev_code_buffer:
           draw_text(GAME_SURFACE, f"Code Input: {dev_code_buffer}", 30, SCREEN_WIDTH // 2, SCREEN_HEIGHT - 60, YELLOW)


       # Final Blit and Flip (Uses calculated offset for centering)
       screen.fill(BLACK)
       scaled_surface = pygame.transform.scale(GAME_SURFACE, (scaled_game_width, scaled_game_height))
       screen.blit(scaled_surface, (x_offset, y_offset))
       pygame.display.flip() # <--- CRITICAL FIX 5: FLIP ADDED TO LEADERBOARD LOOP
       clock.tick(FPS)
   return "MENU"


def show_dev_menu():
   """New screen for the owner's menu (Code: 1223)."""
   global game_state, sight_mode, high_score # CRITICAL: Added high_score to global scope
  
   waiting = True
   while waiting:
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               return "QUIT"
           if event.type == pygame.KEYDOWN:
               if event.key == pygame.K_m:
                   save_config()
                   return "MENU"
               if event.key == pygame.K_r:
                   # --- FIXED: Now updates the global high_score variable ---
                   reset_all_history()
                   load_config()
                   high_score = initialize_leaderboards_and_config() # Assignment added
                   # --------------------------------------------------------
               if event.key == pygame.K_t:
                   sight_mode = not sight_mode
               if event.key == pygame.K_f or event.key == pygame.K_F11:
                   toggle_fullscreen()
                  
       GAME_SURFACE.fill(BLACK)
       draw_text(GAME_SURFACE, "DEVELOPER MENU (Code 1223)", 72, SCREEN_WIDTH // 2, 80, RED)
      
       # 1. Ship Queue Sight Mode Toggle
       sight_status_color = YELLOW if sight_mode else WHITE
       draw_text(GAME_SURFACE, f"Ship Queue Sight Mode (T): {'ON' if sight_mode else 'OFF'}", 45, SCREEN_WIDTH // 2, 250, sight_status_color)
       draw_text(GAME_SURFACE, "Toggles red lines showing enemy spawn locations.", 36, SCREEN_WIDTH // 2, 300, GRAY)
      
       # 2. Reset All History
       draw_text(GAME_SURFACE, "Press R to PERMANENTLY ERASE ALL HISTORY", 36, SCREEN_WIDTH // 2, 450, ORANGE)
       # --- UPDATED TEXT HERE ---
       draw_text(GAME_SURFACE, "(Deletes all data: Leaderboards, Games Played, and Sight Mode)", 30, SCREEN_WIDTH // 2, 490, GRAY)
       # -------------------------
      
       if games_played == 0 and high_score == 0 and not sight_mode: # Added high_score check
            draw_text(GAME_SURFACE, "History & Sight Mode Cleared!", 36, SCREEN_WIDTH // 2, 550, GREEN)
           
       draw_text(GAME_SURFACE, "Press M to return to Menu", 36, SCREEN_WIDTH // 2, SCREEN_HEIGHT - 60, CYAN_BLUE)
      
       # Final Blit and Flip (Uses calculated offset for centering)
       screen.fill(BLACK)
       scaled_surface = pygame.transform.scale(GAME_SURFACE, (scaled_game_width, scaled_game_height))
       screen.blit(scaled_surface, (x_offset, y_offset))
       pygame.display.flip() # <--- CRITICAL FIX 6: FLIP ADDED TO DEV MENU LOOP
       clock.tick(FPS)
   return "MENU"




def handle_life_loss_escape():
   """
   Handles multiple enemies escaping in the same frame,
   deducting a life for each and granting 2s invincibility if player survives.
   """
   global lives, lives_lost_since_level, hit_streak, score_multiplier, perfect_round_streak, player
  
   enemies_escaped = 0
  
   # Identify and count all enemies that escaped
   for enemy in enemies:
       if enemy.rect.top > SCREEN_HEIGHT:
           enemy.kill()
           enemies_escaped += 1
          
   if enemies_escaped > 0:
       # Deduct a life for every single escape
       lives_lost_this_frame = enemies_escaped
       lives -= lives_lost_this_frame
       lives_lost_since_level += lives_lost_this_frame
      
       # Reset streaks on life loss
       hit_streak = 0
       score_multiplier = 1.0
       perfect_round_streak = 0
      
       # Grant invincibility if the player is still alive
       if lives > 0:
            player.invincible = True
            player.last_hit_time = pygame.time.get_ticks()
            player.flash_timer = 0
           
   # No return value needed, as all state changes are global


# --- 6. MAIN GAME EXECUTION ---


high_score = initialize_leaderboards_and_config()


# Ensure initial offsets are calculated for windowed mode
x_offset = 0
y_offset = 0
scaled_game_width = SCREEN_WIDTH
scaled_game_height = SCREEN_HEIGHT


running = True
game_state = "MENU"


while running:
  
   if game_state == "MENU":
      
       editing_username = False
       input_rect_w = 400
       input_rect_h = 60 
       input_rect_x = (SCREEN_WIDTH - input_rect_w) // 2
       input_rect_y = (SCREEN_HEIGHT // 2) + 60
       input_rect = pygame.Rect(input_rect_x, input_rect_y, input_rect_w, input_rect_h)


       waiting = True
       while waiting:
           for event in pygame.event.get():
               if event.type == pygame.QUIT:
                   running = False
                   waiting = False
                   continue
                  
               # --- Mouse Translation Logic ---
               if event.type == pygame.MOUSEBUTTONDOWN: # Corrected to MOUSEBUTTONDOWN
                   if scaled_game_width > 0 and scaled_game_height > 0:
                       relative_x = event.pos[0] - x_offset
                       relative_y = event.pos[1] - y_offset
                       scale_factor_x = SCREEN_WIDTH / scaled_game_width
                       scale_factor_y = SCREEN_HEIGHT / scaled_game_height
                       translated_x = int(relative_x * scale_factor_x)
                       translated_y = int(relative_y * scale_factor_y)
                       translated_pos = (translated_x, translated_y)
                   else:
                       translated_pos = event.pos
                  
                   if input_rect.collidepoint(translated_pos):
                       editing_username = True
                   else:
                       editing_username = False
               # -------------------------------
                      
               if event.type == pygame.KEYDOWN:
                   if editing_username:
                       if event.key == pygame.K_RETURN:
                           game_state = "PLAYING"
                           waiting = False
                       elif event.key == pygame.K_BACKSPACE:
                           username = username[:-1]
                       else:
                           if len(username) < 15:
                               username += event.unicode
                   else:
                       if event.key == pygame.K_p:
                           game_state = "PLAYING"
                           waiting = False
                       if event.key == pygame.K_l:
                           game_state = "LEADERBOARD"
                           waiting = False
                       if event.key == pygame.K_f or event.key == pygame.K_F11:
                            toggle_fullscreen()


           # --- DRAW / RENDER to GAME_SURFACE ---
           GAME_SURFACE.fill(BLACK)
           draw_text(GAME_SURFACE, "SPACE SHOOTER", 72, SCREEN_WIDTH // 2, SCREEN_HEIGHT // 4, GREEN)
          
           # --- UPDATED: High Score position adjusted and Games Played added ---
           draw_text(GAME_SURFACE, f"HIGH SCORE: {high_score}", 50, SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 30)
          
           draw_text(GAME_SURFACE, f"GAMES PLAYED: {games_played}", 36, SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 10, YELLOW)
           # -------------------------------------------------------------------
          
           draw_text(GAME_SURFACE, "Username:", 36, SCREEN_WIDTH // 2, input_rect_y - 30)
          
           box_color = YELLOW if editing_username else WHITE
           pygame.draw.rect(GAME_SURFACE, box_color, input_rect, 2)
          
           draw_text(GAME_SURFACE, username, 50, input_rect.x + input_rect_w // 2, input_rect.y + 5, WHITE, align="center")
          
           if editing_username and (pygame.time.get_ticks() // 500) % 2 == 0:
               text_surface = font_menu.render(username, True, WHITE)
               cursor_surface = font_menu.render("|", True, WHITE)
               cursor_rect = cursor_surface.get_rect()
              
               # Center cursor based on text width
               cursor_pos_x = input_rect.x + input_rect_w // 2 + text_surface.get_width() // 2 + 5
               cursor_rect.topleft = (cursor_pos_x, input_rect.y + 5)
               GAME_SURFACE.blit(cursor_surface, cursor_rect)


           draw_text(GAME_SURFACE, "Press P to Play (or Enter)", 36, SCREEN_WIDTH // 2, SCREEN_HEIGHT * 3 // 4)
           draw_text(GAME_SURFACE, "Press L for Leaderboard", 36, SCREEN_WIDTH // 2, SCREEN_HEIGHT * 3 // 4 + 40)
           draw_text(GAME_SURFACE, "Press F or F11 for Fullscreen", 30, SCREEN_WIDTH // 2, SCREEN_HEIGHT - 40, GRAY)


           # --- NEW UPDATE NUMBER ADDED HERE ---
           draw_text(GAME_SURFACE, "update:1.0.1", 24, SCREEN_WIDTH - 20, SCREEN_HEIGHT - 20, GRAY, align="right")
           # ------------------------------------


           # Final Blit and Flip (Uses calculated offset for centering)
           screen.fill(BLACK)
           scaled_surface = pygame.transform.scale(GAME_SURFACE, (scaled_game_width, scaled_game_height))
           screen.blit(scaled_surface, (x_offset, y_offset))
           pygame.display.flip() # <--- CRITICAL FIX 3: ADDED FLIP TO MENU LOOP
           clock.tick(FPS)
          
       if game_state == "PLAYING":
           reset_game()
          
   elif game_state == "PLAYING":
      
       # Power-up Timer Decrement
       if fire_rate_boost_timer > 0:
           fire_rate_boost_timer -= 1
      
       if invincible_powerup_timer > 0:
           invincible_powerup_timer -= 1
      
       current_multi_shot = int(powerup_multi_shot)
      
       for event in pygame.event.get():
           if event.type == pygame.QUIT:
               running = False
           if event.type == pygame.KEYDOWN:
               if event.key == pygame.K_SPACE:
                   if not paused:
                       player.shoot()
               if event.key == pygame.K_p:
                   paused = not paused
                  
               if event.key == pygame.K_ESCAPE:
                   game_state = "MENU"
              
               if event.key == pygame.K_f or event.key == pygame.K_F11:
                   toggle_fullscreen()


       if not paused:
           all_sprites.update()
          
           # --- Collision Detection ---
           hits = pygame.sprite.groupcollide(bullets, enemies, True, True)
          
           for bullet, hit_enemies in hits.items():
               hit_streak += 1
               score_multiplier += 0.5
               max_hit_streak_achieved = max(max_hit_streak_achieved, hit_streak)


               for enemy in hit_enemies:
                   explosion = Explosion(enemy.rect.center)
                   all_sprites.add(explosion)
                   enemies_killed_total += 1
                  
                   # Decrement the lucky block counter
                   kills_to_next_lucky_block -= 1


                   TOP_ZONE_HEIGHT = 100
                   BOTTOM_ZONE_HEIGHT = 100
                   base_score_awarded = 10
                   if enemy.rect.bottom > SCREEN_HEIGHT - BOTTOM_ZONE_HEIGHT:
                       base_score_awarded = 15
                   elif enemy.rect.top < TOP_ZONE_HEIGHT:
                       base_score_awarded = 5
                      
                   final_score_awarded = round(base_score_awarded * score_multiplier)
                   score += final_score_awarded
          
           lucky_hits = pygame.sprite.groupcollide(bullets, lucky_blocks, True, True)
           for bullet, hit_blocks in lucky_hits.items():
               for block in hit_blocks:
                   apply_powerup()
                   block.kill()


           # --- Life Loss for Escaped Enemies ---
           handle_life_loss_escape()
          
           # --- Life Loss for Player Hits ---
           player_hits = pygame.sprite.spritecollide(player, enemies, True)
          
           if player_hits and not player.invincible and invincible_powerup_timer <= 0:
              
               # Kill and explode all enemies that hit the player this frame
               for enemy in player_hits:
                   explosion = Explosion(enemy.rect.center)
                   all_sprites.add(explosion)
              
               # Lose one life and trigger standard invincibility
               lives -= 1
               lives_lost_since_level += 1
               hit_streak = 0
               score_multiplier = 1.0
               perfect_round_streak = 0
               player.invincible = True
               player.last_hit_time = pygame.time.get_ticks()
               player.flash_timer = 0
              
           check_and_spawn_enemies()
          
           if lives <= 0:
               update_leaderboards(username, score, max_hit_streak_achieved, perfect_round_streak)
               high_score = initialize_leaderboards_and_config()
               game_state = "GAME_OVER"


       # --- DRAW / RENDER to GAME_SURFACE ---
       GAME_SURFACE.fill(BLACK)
       all_sprites.draw(GAME_SURFACE)
      
       # Calculate Next Level Score
       next_level_score_needed = calculate_score_for_next_level(score_level)


       # Draw UI
       # Top Row (Score, Hit Streak, Lives)
       draw_text(GAME_SURFACE, f"Score: {score}", 36, 120, 10, align="left")
       draw_text(GAME_SURFACE, f"Lives: {lives}", 36, SCREEN_WIDTH - 120, 10, align="right")
       draw_text(GAME_SURFACE, f"x{score_multiplier:.1f} STREAK: {hit_streak}", 36, SCREEN_WIDTH // 2, 10, YELLOW, align="center")


       # Second Row (Perfect Pilot Streak, Next Level)
       draw_text(GAME_SURFACE, f"PERFECT PILOT: {perfect_round_streak}", 45, SCREEN_WIDTH // 2, 45, CYAN_BLUE, align="center")
      
       # Third Row (Games Played, Power-up Status, Next Level Score)
       draw_text(GAME_SURFACE, f"Games Played: {games_played}", 24, 10, 80, GRAY, align="left")
      
       # --- NEW NEXT LEVEL DISPLAY ---
       draw_text(GAME_SURFACE, f"NEXT LEVEL: {next_level_score_needed}", 24, 10, 110, GRAY, align="left")
       # ----------------------------
      
       # Draw Power-up Status - Updated names here
       powerup_status = []
       if fire_rate_boost_timer > 0:
           name = "PULSE" if fire_rate_boost_timer < LONG_DURATION else "HYPERBURNER"
           powerup_status.append(f"{name}: {fire_rate_boost_timer // FPS + 1}s")
       if current_multi_shot == 2:
           powerup_status.append(f"DUAL CANON")
       elif current_multi_shot == 3:
           powerup_status.append(f"TRI-SPLINTER")
       if invincible_powerup_timer > 0:
           name = "PHASE SHIELD" if invincible_powerup_timer < LONG_DURATION else "QUANTUM CLOAK"
           powerup_status.append(f"{name}: {invincible_powerup_timer // FPS + 1}s")
       if streak_saver_active:
            powerup_status.append("SAVER READY")


       draw_text(GAME_SURFACE, " | ".join(powerup_status), 28, SCREEN_WIDTH // 2, 80, BLUE, align="center")


       # Sight Mode Debugging Info (Ship Queue Visualization)
       if sight_mode:
           for x_pos in scheduled_spawns:
               # Draw left border of the next enemy spawn area
               pygame.draw.line(GAME_SURFACE, RED, (x_pos, 0), (x_pos, SCREEN_HEIGHT), 1)
               # Draw right border of the next enemy spawn area (30px width)
               pygame.draw.line(GAME_SURFACE, RED, (x_pos + 30, 0), (x_pos + 30, SCREEN_HEIGHT), 1)


           # --- UPDATED DEBUG DISPLAY (Showing kills remaining) ---
           if len(lucky_blocks) == 0 and kills_to_next_lucky_block <= 0:
                draw_text(GAME_SURFACE, "LUCKY BLOCK DUE", 24, SCREEN_WIDTH // 2, 110, BLUE, align="center")
           elif len(lucky_blocks) == 0:
                draw_text(GAME_SURFACE, f"LUCKY BLOCK IN: {kills_to_next_lucky_block}", 24, SCREEN_WIDTH // 2, 110, BLUE, align="center")
           # -----------------------------------------------------


       if paused:
           show_pause_screen(GAME_SURFACE)


       # Final Blit and Flip (Uses calculated offset for centering)
       screen.fill(BLACK)
       scaled_surface = pygame.transform.scale(GAME_SURFACE, (scaled_game_width, scaled_game_height))
       screen.blit(scaled_surface, (x_offset, y_offset))
       pygame.display.flip()
       clock.tick(FPS)
  
   # --- GAME OVER STATE ---
   elif game_state == "GAME_OVER":
       final_score_display = score
       action = show_game_over_screen(final_score_display)
      
       if action == "MENU":
           game_state = "MENU"
       elif action == "PLAY":
           game_state = "PLAYING"
           reset_game()
       elif action == "QUIT":
           running = False


   # --- LEADERBOARD STATE ---
   elif game_state == "LEADERBOARD":
       action = show_leaderboard_screen()
       if action == "DEV_MENU":
           game_state = "DEV_MENU"
       elif action == "QUIT":
           running = False
       else:
           game_state = "MENU"
          
   # --- DEV MENU STATE ---
   elif game_state == "DEV_MENU":
       action = show_dev_menu()
       if action == "QUIT":
           running = False
       else:
           game_state = "MENU"


# --- 7. CLEANUP ---
save_config()
pygame.quit()
sys.exit();

    </script>

</body>
</html>